了解しました。以下に、指定された要件を満たすために必要な修正箇所のみを端的に示します。

1. クライアント側の修正

a. 新規コンポーネント Login.tsx の追加

ファイル: client/src/components/Login.tsx

// client/src/components/Login.tsx
import React from 'react';
import { v4 as uuidv4 } from 'uuid';
import './Login.css';

interface LoginProps {
  onLogin: (userId: string, mode: 'task' | 'practice') => void;
}

const Login: React.FC<LoginProps> = ({ onLogin }) => {
  const handleStartTask = () => {
    const userId = uuidv4();
    onLogin(userId, 'task');
  };

  const handlePractice = () => {
    const userId = uuidv4();
    onLogin(userId, 'practice');
  };

  return (
    <div className='login-container'>
      <h2>ようこそ！</h2>
      <button className='btn' onClick={handleStartTask}>
        課題を開始する
      </button>
      <button className='btn' onClick={handlePractice}>
        練習問題を解く
      </button>
    </div>
  );
};

export default Login;

b. スタイルシート Login.css の追加

ファイル: client/src/components/Login.css

/* client/src/components/Login.css */
.login-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    background-color: #f8f9fa;
}

.login-container h2 {
    margin-bottom: 20px;
    color: #333;
}

.login-container .btn {
    width: 200px;
    padding: 10px;
    margin: 10px 0;
    background-color: #007bff;
    border: none;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1em;
}

.login-container .btn:hover {
    background-color: #0056b3;
}

c. App.tsx の修正

ファイル: client/src/App.tsx

// client/src/App.tsx
import React, { useEffect, useState } from 'react';
import tasksData from './data/tasks.json';
import Timer from './components/Timer';
import TaskRunner from './components/TaskRunner';
import Login from './components/Login';
import './styles/style.css';

function App() {
  const [currentTaskIndex, setCurrentTaskIndex] = useState(0);
  const [disqualified, setDisqualified] = useState(false);
  const [timerKey, setTimerKey] = useState(0); // タイマーリセット用のキー
  const [userId, setUserId] = useState<string | null>(null);
  const [mode, setMode] = useState<'task' | 'practice' | null>(null);

  const currentTask = tasksData[currentTaskIndex];

  // タブがhiddenになったら失格
  useEffect(() => {
    const onVisibilityChange = () => {
      if (document.visibilityState === 'hidden') {
        setDisqualified(true);
      }
    };
    document.addEventListener('visibilitychange', onVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', onVisibilityChange);
    };
  }, []);

  const handleTimeUp = () => {
    setDisqualified(true);
  };

  const handleNextTask = () => {
    setCurrentTaskIndex((prev) => (prev + 1) % tasksData.length);
    setDisqualified(false);
    setTimerKey(prev => prev + 1); // タイマーをリセット
  };

  const handleLogin = (newUserId: string, selectedMode: 'task' | 'practice') => {
    setUserId(newUserId);
    setMode(selectedMode);
  };

  if (!userId || !mode) {
    return <Login onLogin={handleLogin} />;
  }

  if (disqualified) {
    return (
      <div className='container'>
        <div className='disqualified'>失格になりました...(タブが非アクティブ)</div>
        <button className='btn' onClick={handleNextTask}>
          次の課題へ
        </button>
      </div>
    );
  }

  // モードが "practice" の場合のコンポーネントを追加することができます
  // ここでは仮に TaskRunner を表示するようにしています
  return (
    <div className='container'>
      <div className='title'>ローカル競プロ学習アプリ</div>

      <div className='timer'>
        <Timer key={timerKey} totalSec={currentTask.timeLimitSec} onTimeUp={handleTimeUp} />
      </div>

      <div style={{ marginBottom: '10px' }}>
        <button
          className='btn'
          onClick={handleNextTask}
        >
          次の課題へ
        </button>
      </div>

      <TaskRunner task={currentTask} userId={userId} mode={mode} />
    </div>
  );
}

export default App;

d. TaskRunner.tsx の修正

ファイル: client/src/components/TaskRunner.tsx

// client/src/components/TaskRunner.tsx
import React, { useState, useEffect } from 'react';
import CodeEditor from './CodeEditor';
import './TaskRunner.css';
import defaultCodes from '../data/defaultCodes.json';

interface TestCase {
  input: string;
  output: string;
}

interface Task {
  id: number;
  title: string;
  description: string;
  timeLimitSec: number;
  testCases: TestCase[];
}

interface TaskRunnerProps {
  task: Task;
  userId: string;
  mode: 'task' | 'practice';
}

const TaskRunner: React.FC<TaskRunnerProps> = ({ task, userId, mode }) => {
  const [language, setLanguage] = useState<'csharp' | 'typescript'>('csharp');
  const [userCode, setUserCode] = useState('');
  const [sampleIndex, setSampleIndex] = useState(0);
  const [output, setOutput] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  useEffect(() => {
    // 言語が変更された際にデフォルトのコードを設定
    setUserCode(defaultCodes[language]);
  }, [language]);

  const handleCompileAndTest = async () => {
    setIsSubmitting(true);
    setOutput('実行中...');
    const testCase = task.testCases[sampleIndex];
    if (!testCase) {
      setOutput('テストケースが選択されていません');
      setIsSubmitting(false);
      return;
    }
    try {
      const url = language === 'csharp' ? '/api/run-cs' : '/api/run-ts';
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ code: userCode, input: testCase.input, userId, mode })
      });
      const data = await res.json();
      if (!data.success) {
        setOutput(`エラー:\n${data.output}`);
      } else {
        setOutput(data.output);
      }
    } catch (err: any) {
      setOutput(`通信エラー: ${err.message}`);
    }
    setIsSubmitting(false);
  };

  const handleSubmit = async () => {
    setIsSubmitting(true);
    setOutput('提出中...');
    let resultMessage = '';
    let allPassed = true;

    for (const tc of task.testCases) {
      try {
        const url = language === 'csharp' ? '/api/run-cs' : '/api/run-ts';
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code: userCode, input: tc.input, userId, mode })
        });
        const data = await res.json();
        if (!data.success) {
          allPassed = false;
          resultMessage += `【NG】入力: ${tc.input}\nエラー:\n${data.output}\n\n`;
        } else {
          const actual = data.output.trim();
          const expected = tc.output.trim();
          if (actual === expected) {
            resultMessage += `【OK】入力: ${tc.input}\n => ${actual}\n\n`;
          } else {
            allPassed = false;
            resultMessage += `【NG】入力: ${tc.input}\n 期待値: ${expected}, 実際: ${actual}\n\n`;
          }
        }
      } catch (error: any) {
        allPassed = false;
        resultMessage += `【ERR】${error.message}\n\n`;
      }
    }

    if (allPassed) {
      setOutput(`全テストケース合格！\n\n${resultMessage}`);
    } else {
      setOutput(`一部失敗:\n\n${resultMessage}`);
    }
    setIsSubmitting(false);
  };

  return (
    <div>
      <h3>{task.title}</h3>
      <div className='task-description'>
        <pre>{task.description}</pre>
      </div>

      {/* テストケースの詳細表示 */}
      <div className='test-case-details'>
        <h4>テストケースの詳細表示</h4>
        {task.testCases.map((tc) => (
          <div key={tc.input} className='individual-test-case'>
            <h5>テストケース {task.testCases.indexOf(tc) + 1}</h5>
            <div>
              <strong>入力:</strong>
              <pre>{tc.input}</pre>
            </div>
            <div>
              <strong>期待される出力:</strong>
              <pre>{tc.output}</pre>
            </div>
          </div>
        ))}
      </div>

      {/* テストケース選択と動作確認 */}
      <div style={{ margin: '10px 0' }}>
        <label htmlFor="testcase-select">テストケース: </label>
        <select
          id="testcase-select"
          value={sampleIndex}
          onChange={(e) => setSampleIndex(Number(e.target.value))}
        >
          {task.testCases.map((tc) => (
            <option key={tc.input} value={task.testCases.indexOf(tc)}>
              入力例{task.testCases.indexOf(tc) + 1}
            </option>
          ))}
        </select>

        <button className='btn' onClick={handleCompileAndTest} disabled={isSubmitting}>
          {isSubmitting ? '実行中...' : '提出前動作確認'}
        </button>
      </div>

      <button className='btn' onClick={handleSubmit} disabled={isSubmitting}>
        {isSubmitting ? '提出中...' : 'コードを提出する'}
      </button>

      <div className='output'>
        <pre>{output}</pre>
      </div>
    </div>
  );
};

export default TaskRunner;

e. スタイルシート Login.css の追加

（上記で Login.css を追加済みのため、重複していません。）

2. サーバー側の修正

a. server/runCode.ts の修正

ユーザーごとにタスクを管理するために、ユーザーIDとモードを受け取るようにします。また、サーバー側でアクティブなタスクを追跡する必要があります。

ファイル: server/runCode.ts

// server/runCode.ts
import { exec } from 'child_process';
import fs from 'fs';
import path from 'path';

const tempDir = path.join(__dirname, '../../temp');

// ユーザーごとのタスク管理
const activeTasks: { [userId: string]: boolean } = {};

// C#コードのコンパイルと実行
export function runCsCode(code: string, input: string, userId: string, mode: 'task' | 'practice'): Promise<string> {
  return new Promise((resolve, reject) => {
    if (activeTasks[userId] && mode === 'task') {
      return reject(new Error('既に課題が実行中です。'));
    }

    if (mode === 'task') {
      activeTasks[userId] = true;
    }

    const csFilePath = path.join(tempDir, `Program_${userId}.cs`);
    fs.writeFileSync(csFilePath, code, 'utf8');

    const compileCmd = `csc "${csFilePath}"`;
    const exePath = path.join(tempDir, `Program_${userId}.exe`);
    const runCmd = `"${exePath}"`;

    exec(compileCmd, { cwd: tempDir }, (compileErr, _stdout, compileStderr) => {
      if (compileErr) {
        if (mode === 'task') {
          activeTasks[userId] = false;
        }
        return reject(new Error('C#コンパイルエラー:\n' + compileStderr));
      }
      // 実行時に入力を渡す
      const child = exec(runCmd, { cwd: tempDir }, (runErr, runStdout, runStderr) => {
        if (runErr) {
          if (mode === 'task') {
            activeTasks[userId] = false;
          }
          return reject(new Error('C#実行エラー:\n' + runStderr));
        }
        if (mode === 'task') {
          activeTasks[userId] = false;
        }
        resolve(runStdout.trim());
      });

      // 標準入力にデータを書き込む
      child.stdin?.write(input);
      child.stdin?.end();
    });
  });
}

// TypeScriptコードのコンパイルと実行
export function runTsCode(code: string, input: string, userId: string, mode: 'task' | 'practice'): Promise<string> {
  return new Promise((resolve, reject) => {
    if (activeTasks[userId] && mode === 'task') {
      return reject(new Error('既に課題が実行中です。'));
    }

    if (mode === 'task') {
      activeTasks[userId] = true;
    }

    const tsFilePath = path.join(tempDir, `temp_${userId}.ts`);
    fs.writeFileSync(tsFilePath, code, 'utf8');

    const compileCmd = `tsc "${tsFilePath}" --outDir "${tempDir}"`;
    const jsFilePath = path.join(tempDir, `temp_${userId}.js`);
    const runCmd = `node "${jsFilePath}"`;

    exec(compileCmd, { cwd: tempDir }, (compileErr, _stdout, compileStderr) => {
      if (compileErr) {
        if (mode === 'task') {
          activeTasks[userId] = false;
        }
        return reject(new Error('TypeScriptコンパイルエラー:\n' + compileStderr));
      }
      // 実行時に入力を渡す
      const child = exec(runCmd, { cwd: tempDir }, (runErr, runStdout, runStderr) => {
        if (runErr) {
          if (mode === 'task') {
            activeTasks[userId] = false;
          }
          return reject(new Error('TypeScript実行エラー:\n' + runStderr));
        }
        if (mode === 'task') {
          activeTasks[userId] = false;
        }
        resolve(runStdout.trim());
      });

      // 標準入力にデータを書き込む
      child.stdin?.write(input);
      child.stdin?.end();
    });
  });
}

b. server/server.ts の修正

ユーザーごとにタスクを管理するために、リクエストから userId と mode を受け取り、runCsCode と runTsCode に渡します。

ファイル: server/server.ts

// server/server.ts
import express from 'express';
import { runCsCode, runTsCode } from './runCode';
import cors from 'cors';
import path from 'path';

const app = express();
const PORT = 4000;

// CORS設定（必要に応じて調整）
app.use(cors());

// JSONパースミドルウェア
app.use(express.json());

// 静的ファイルの提供（必要に応じて）
app.use(express.static(path.join(__dirname, '../../client/build')));

// C#コード実行エンドポイント
app.post('/api/run-cs', async (req, res) => {
  const { code, input, userId, mode } = req.body;
  if (!userId || !mode) {
    return res.status(400).json({ success: false, output: 'userIdとmodeが必要です。' });
  }
  try {
    const output = await runCsCode(code, input, userId, mode);
    res.json({ success: true, output });
  } catch (error: any) {
    res.json({ success: false, output: error.message });
  }
});

// TypeScriptコード実行エンドポイント
app.post('/api/run-ts', async (req, res) => {
  const { code, input, userId, mode } = req.body;
  if (!userId || !mode) {
    return res.status(400).json({ success: false, output: 'userIdとmodeが必要です。' });
  }
  try {
    const output = await runTsCode(code, input, userId, mode);
    res.json({ success: true, output });
  } catch (error: any) {
    res.json({ success: false, output: error.message });
  }
});

// 全てのルートをReactアプリにフォワード
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '../../client/build', 'index.html'));
});

// サーバー起動
app.listen(PORT, () => {
  console.log(`Server listening on http://localhost:${PORT}`);
});

3. 必要な依存関係の追加

a. uuid パッケージのインストール

ユーザーIDを生成するために uuid パッケージを使用します。

コマンド:

cd client
npm install uuid

b. 型定義ファイルのインストール

TypeScriptで uuid を使用するために型定義ファイルをインストールします。

コマンド:

npm install --save-dev @types/uuid

4. その他の考慮事項

a. サーバーのセキュリティ強化

現在の設定では、ユーザーIDを信頼してタスクを管理していますが、セキュリティ上の観点から、ユーザーIDの検証や認証を導入することをお勧めします。例えば、セッション管理やトークンベースの認証を導入することで、不正なアクセスを防止できます。

b. 練習問題の実装

mode が 'practice' の場合の処理をクライアント側およびサーバー側で実装する必要があります。現状では、TaskRunner コンポーネントを共通で使用していますが、練習問題専用のコンポーネントを作成することも検討してください。

まとめ

以上の修正を行うことで、以下の要件を満たすことができます：
	•	複数ユーザーが同時に使用できるように:
	•	ユーザーごとに一意の userId を生成・管理し、サーバー側でアクティブなタスクを追跡します。
	•	アプリの初期画面をパスワードなしのログイン画面に変更:
	•	Login コンポーネントを追加し、ログイン後に userId と選択モードを管理します。
	•	ログイン画面に課題開始ボタンと練習問題解決ボタンを設置:
	•	Login コンポーネント内に2つのボタンを配置し、ユーザーの選択に応じてモードを設定します。
	•	課題は常に一つとする:
	•	サーバー側で activeTasks オブジェクトを使用して、各ユーザーごとに一つの課題のみを許可します。

これにより、ユーザーはアプリを同時に利用でき、課題と練習問題を選択して取り組むことができるようになります。必要に応じて、さらに機能を追加したり、UIを改善したりすることも可能です。

何か他に質問や問題がありましたら、お知らせください。
