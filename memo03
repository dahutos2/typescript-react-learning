承知しました。以下に、指定された要件を満たすために必要な修正箇所のみを端的に示します。

1. クライアント側の修正

a. Login.tsx の修正

ファイル: client/src/components/Login.tsx

修正後:

// client/src/components/Login.tsx
import React, { useState } from 'react';
import './Login.css';

interface LoginProps {
  onLogin: (userId: string) => void;
}

const Login: React.FC<LoginProps> = ({ onLogin }) => {
  const [userIdInput, setUserIdInput] = useState('');

  const handleLogin = () => {
    if (userIdInput.trim() !== '') {
      onLogin(userIdInput.trim());
    }
  };

  return (
    <div className='login-container'>
      <h2>ようこそ！</h2>
      <input
        type="text"
        placeholder="ユーザーIDを入力してください"
        value={userIdInput}
        onChange={(e) => setUserIdInput(e.target.value)}
        className='user-id-input'
      />
      <button className='btn' onClick={handleLogin} disabled={userIdInput.trim() === ''}>
        ログイン
      </button>
    </div>
  );
};

export default Login;

b. App.tsx の修正

ファイル: client/src/App.tsx

修正後:

// client/src/App.tsx
import React, { useEffect, useState } from 'react';
import tasksData from './data/tasks.json';
import Timer from './components/Timer';
import TaskRunner from './components/TaskRunner';
import Login from './components/Login';
import './styles/style.css';

function App() {
  const [currentTaskIndex, setCurrentTaskIndex] = useState(0);
  const [disqualified, setDisqualified] = useState(false);
  const [timerKey, setTimerKey] = useState(0); // タイマーリセット用のキー
  const [userId, setUserId] = useState<string | null>(null);

  const currentTask = tasksData[currentTaskIndex];

  // タブがhiddenになったら失格
  useEffect(() => {
    const onVisibilityChange = () => {
      if (document.visibilityState === 'hidden') {
        setDisqualified(true);
      }
    };
    document.addEventListener('visibilitychange', onVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', onVisibilityChange);
    };
  }, []);

  const handleTimeUp = () => {
    setDisqualified(true);
  };

  const handleLogin = (newUserId: string) => {
    setUserId(newUserId);
  };

  if (!userId) {
    return <Login onLogin={handleLogin} />;
  }

  if (disqualified) {
    return (
      <div className='container'>
        <div className='disqualified'>失格になりました...(タブが非アクティブ)</div>
        {/* 次の課題ボタンを削除 */}
      </div>
    );
  }

  return (
    <div className='container'>
      <div className='title'>ローカル競プロ学習アプリ</div>

      <div className='timer'>
        <Timer key={timerKey} totalSec={currentTask.timeLimitSec} onTimeUp={handleTimeUp} />
      </div>

      {/* 次の課題ボタンを削除 */}

      <TaskRunner task={currentTask} userId={userId} />
    </div>
  );
}

export default App;

c. TaskRunner.tsx の修正

ファイル: client/src/components/TaskRunner.tsx

修正後:

// client/src/components/TaskRunner.tsx
import React, { useState, useEffect } from 'react';
import CodeEditor from './CodeEditor';
import './TaskRunner.css';
import defaultCodes from '../data/defaultCodes.json';

interface TestCase {
  input: string;
  output: string;
}

interface Task {
  id: number;
  title: string;
  description: string;
  timeLimitSec: number;
  testCases: TestCase[];
}

interface TaskRunnerProps {
  task: Task;
  userId: string;
}

const TaskRunner: React.FC<TaskRunnerProps> = ({ task, userId }) => {
  const [language, setLanguage] = useState<'csharp' | 'typescript'>('csharp');
  const [userCode, setUserCode] = useState('');
  const [sampleIndex, setSampleIndex] = useState(0);
  const [output, setOutput] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  useEffect(() => {
    // 言語が変更された際にデフォルトのコードを設定
    setUserCode(defaultCodes[language]);
  }, [language]);

  const handleCompileAndTest = async () => {
    setIsSubmitting(true);
    setOutput('実行中...');
    const testCase = task.testCases[sampleIndex];
    if (!testCase) {
      setOutput('テストケースが選択されていません');
      setIsSubmitting(false);
      return;
    }
    try {
      const url = language === 'csharp' ? '/api/run-cs' : '/api/run-ts';
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ code: userCode, input: testCase.input, userId })
      });
      const data = await res.json();
      if (!data.success) {
        setOutput(`エラー:\n${data.output}`);
      } else {
        setOutput(data.output);
      }
    } catch (err: any) {
      setOutput(`通信エラー: ${err.message}`);
    }
    setIsSubmitting(false);
  };

  const handleSubmit = async () => {
    setIsSubmitting(true);
    setOutput('提出中...');
    let resultMessage = '';
    let allPassed = true;

    for (const tc of task.testCases) {
      try {
        const url = language === 'csharp' ? '/api/run-cs' : '/api/run-ts';
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code: userCode, input: tc.input, userId })
        });
        const data = await res.json();
        if (!data.success) {
          allPassed = false;
          resultMessage += `【NG】入力: ${tc.input}\nエラー:\n${data.output}\n\n`;
        } else {
          const actual = data.output.trim();
          const expected = tc.output.trim();
          if (actual === expected) {
            resultMessage += `【OK】入力: ${tc.input}\n => ${actual}\n\n`;
          } else {
            allPassed = false;
            resultMessage += `【NG】入力: ${tc.input}\n 期待値: ${expected}, 実際: ${actual}\n\n`;
          }
        }
      } catch (error: any) {
        allPassed = false;
        resultMessage += `【ERR】${error.message}\n\n`;
      }
    }

    if (allPassed) {
      setOutput(`全テストケース合格！\n\n${resultMessage}`);
    } else {
      setOutput(`一部失敗:\n\n${resultMessage}`);
    }
    setIsSubmitting(false);
  };

  return (
    <div>
      <h3>{task.title}</h3>
      <div className='task-description'>
        <pre>{task.description}</pre>
      </div>

      {/* テストケースの詳細表示 */}
      <div className='test-case-details'>
        <h4>テストケースの詳細表示</h4>
        {task.testCases.map((tc) => (
          <div key={tc.input} className='individual-test-case'>
            <h5>テストケース {task.testCases.indexOf(tc) + 1}</h5>
            <div>
              <strong>入力:</strong>
              <pre>{tc.input}</pre>
            </div>
            <div>
              <strong>期待される出力:</strong>
              <pre>{tc.output}</pre>
            </div>
          </div>
        ))}
      </div>

      {/* テストケース選択と動作確認 */}
      <div style={{ margin: '10px 0' }}>
        <label htmlFor="testcase-select">テストケース: </label>
        <select
          id="testcase-select"
          value={sampleIndex}
          onChange={(e) => setSampleIndex(Number(e.target.value))}
        >
          {task.testCases.map((tc, idx) => (
            <option key={tc.input} value={idx}>
              入力例{idx + 1}
            </option>
          ))}
        </select>

        <button className='btn' onClick={handleCompileAndTest} disabled={isSubmitting}>
          {isSubmitting ? '実行中...' : '提出前動作確認'}
        </button>
      </div>

      <button className='btn' onClick={handleSubmit} disabled={isSubmitting}>
        {isSubmitting ? '提出中...' : 'コードを提出する'}
      </button>

      <div className='output'>
        <pre>{output}</pre>
      </div>
    </div>
  );
};

export default TaskRunner;

2. サーバー側の修正

a. runCode.ts の修正

ファイル: server/runCode.ts

修正後:

// server/runCode.ts
import { exec } from 'child_process';
import fs from 'fs';
import path from 'path';

const tempDir = path.join(__dirname, '../../temp');

// ユーザーごとのタスク管理
const activeTasks: { [userId: string]: boolean } = {};

// C#コードのコンパイルと実行
export function runCsCode(code: string, input: string, userId: string): Promise<string> {
  return new Promise((resolve, reject) => {
    if (activeTasks[userId]) {
      return reject(new Error('既にタスクが実行中です。'));
    }

    activeTasks[userId] = true;

    const csFilePath = path.join(tempDir, `Program_${userId}.cs`);
    fs.writeFileSync(csFilePath, code, 'utf8');

    const compileCmd = `csc "${csFilePath}"`;
    const exePath = path.join(tempDir, `Program_${userId}.exe`);
    const runCmd = `"${exePath}"`;

    exec(compileCmd, { cwd: tempDir }, (compileErr, _stdout, compileStderr) => {
      if (compileErr) {
        activeTasks[userId] = false;
        return reject(new Error('C#コンパイルエラー:\n' + compileStderr));
      }
      // 実行時に入力を渡す
      const child = exec(runCmd, { cwd: tempDir }, (runErr, runStdout, runStderr) => {
        if (runErr) {
          activeTasks[userId] = false;
          return reject(new Error('C#実行エラー:\n' + runStderr));
        }
        activeTasks[userId] = false;
        resolve(runStdout.trim());
      });

      // 標準入力にデータを書き込む
      child.stdin?.write(input);
      child.stdin?.end();
    });
  });
}

// TypeScriptコードのコンパイルと実行
export function runTsCode(code: string, input: string, userId: string): Promise<string> {
  return new Promise((resolve, reject) => {
    if (activeTasks[userId]) {
      return reject(new Error('既にタスクが実行中です。'));
    }

    activeTasks[userId] = true;

    const tsFilePath = path.join(tempDir, `temp_${userId}.ts`);
    fs.writeFileSync(tsFilePath, code, 'utf8');

    const compileCmd = `tsc "${tsFilePath}" --outDir "${tempDir}"`;
    const jsFilePath = path.join(tempDir, `temp_${userId}.js`);
    const runCmd = `node "${jsFilePath}"`;

    exec(compileCmd, { cwd: tempDir }, (compileErr, _stdout, compileStderr) => {
      if (compileErr) {
        activeTasks[userId] = false;
        return reject(new Error('TypeScriptコンパイルエラー:\n' + compileStderr));
      }
      // 実行時に入力を渡す
      const child = exec(runCmd, { cwd: tempDir }, (runErr, runStdout, runStderr) => {
        if (runErr) {
          activeTasks[userId] = false;
          return reject(new Error('TypeScript実行エラー:\n' + runStderr));
        }
        activeTasks[userId] = false;
        resolve(runStdout.trim());
      });

      // 標準入力にデータを書き込む
      child.stdin?.write(input);
      child.stdin?.end();
    });
  });
}

b. server.ts の修正

ファイル: server/server.ts

修正後:

// server/server.ts
import express from 'express';
import { runCsCode, runTsCode } from './runCode';
import cors from 'cors';
import path from 'path';

const app = express();
const PORT = 4000;

// CORS設定（必要に応じて調整）
app.use(cors());

// JSONパースミドルウェア
app.use(express.json());

// 静的ファイルの提供（必要に応じて）
app.use(express.static(path.join(__dirname, '../../client/build')));

// C#コード実行エンドポイント
app.post('/api/run-cs', async (req, res) => {
  const { code, input, userId } = req.body;
  if (!userId) {
    return res.status(400).json({ success: false, output: 'userIdが必要です。' });
  }
  try {
    const output = await runCsCode(code, input, userId);
    res.json({ success: true, output });
  } catch (error: any) {
    res.json({ success: false, output: error.message });
  }
});

// TypeScriptコード実行エンドポイント
app.post('/api/run-ts', async (req, res) => {
  const { code, input, userId } = req.body;
  if (!userId) {
    return res.status(400).json({ success: false, output: 'userIdが必要です。' });
  }
  try {
    const output = await runTsCode(code, input, userId);
    res.json({ success: true, output });
  } catch (error: any) {
    res.json({ success: false, output: error.message });
  }
});

// 全てのルートをReactアプリにフォワード
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '../../client/build', 'index.html'));
});

// サーバー起動
app.listen(PORT, () => {
  console.log(`Server listening on http://localhost:${PORT}`);
});

3. 依存関係の修正

a. uuid パッケージの削除

これまでユーザーIDを自動生成していましたが、ユーザーが入力するため、uuid パッケージは不要になります。

コマンド:

cd client
npm uninstall uuid @types/uuid

b. 不要なプロパティの削除

TaskRunner コンポーネントから mode プロパティの使用を完全に削除します。

ファイル: client/src/components/TaskRunner.tsx

修正後:

既に mode を削除しているため、追加の修正は不要です。

4. その他の考慮事項

a. TaskRunner.css の確認

TaskRunner.tsx 内で mode に関連するスタイルが存在しないか確認し、不要なスタイルがあれば削除します。

ファイル: client/src/components/TaskRunner.css

修正箇所: 不要なスタイルがあれば削除（具体的な修正は現状不要と判断）

b. サーバーのセキュリティ強化

ユーザーIDの信頼性を確保するため、簡易的な認証や入力検証を導入することを推奨します。例えば、ユーザーIDの形式を制限するなどです。

まとめ

以上の修正を行うことで、以下の要件を満たすことができます：
	•	ユーザーの識別:
	•	ログイン画面でユーザーが自身のIDを入力してログインします。
	•	モードの削除と簡単な練習問題の表示:
	•	モードの概念を廃止し、単一の練習問題を表示します。
	•	「次の課題」の削除:
	•	複数課題の管理を廃止し、常に一つの課題のみを扱います。

これにより、アプリは複数ユーザーが同時に利用可能となり、ユーザーは自身のIDで識別され、シンプルな練習問題に取り組むことができるようになります。

何か他に質問や問題がありましたら、お知らせください。
